{
  "comments": [
    {
      "date": "2013-10-21T09:57:10Z",
      "name": "Matt Robinson",
      "comment": "Django was my first web framework, and I still have fondness for it and Python (and its sexy sexy template language). One small hole to poke in your routing complaint:\n\nThe Router component only matches the incoming URL on the Request object to its URL map, and sets attributes on the Request. One of those attributes is called <code>_controller</code>, and as far as the Symfony kernel is concerned, the only requirement it has is that the <code>ControllerResolver</code> can turn it into a callable (if it's not one already). Silex's compact Sinatra-like syntax is just syntactic sugar which creates a Route object with the given callable as its <code>_controller</code> attribute, then adds it to the router's URL map.\n\nThe damage is caused by the alternative <code>ControllerResolver</code> supplied by <code>FrameworkBundle</code>, which can only handle <code>bundle:controller:method</code>, <code>service:method</code>, or <code>classname::method</code> string. It's pretty simple to replace though (I think!). The default <code>HttpKernel</code> <code>ControllerResolver</code> can take any callable, <code>classname::method</code>, function name or closure name (or rather, any class with an <code>__invoke()</code> method).\n\nThat said, just because it's <em>possible</em>, I think it's reasonable for you to say that this isn't easy in Symfony2.\n\nOverall, I'm surprised you didn't stick with Silex, given your opinions on things like YAML, efficiency, and Symfony's conventions. Silex is just Symfony without all the conventions."
    },
    {
      "date": "2013-10-21T10:18:06Z",
      "isAuthorReply": true,
      "comment": "@Matt Robinson: interesting - thanks for pointing out that under the hood, Symfony2 does actually have the concept of a generic callable, and that it can handle any callable as a request handler - I didn't realise that. I haven't delved into Symfony2's internals much yet.\n\nI've also used Silex, and yes, I like that the standard way of writing a callback in Silex is as an anonymous function passed directly to <code>$controllers->get()</code>. You have a point, Silex does a better job of fully exposing the underlying components' ability to handle any type of callable, whereas the Framework Bundle somewhat sabotages this.\n\nRe: why didn't I stick with Silex? Mainly because many third-party Symfony2 extensions are written only as \"bundles\" for the Standard Edition, and not as \"service providers\" for Silex. I.e. many are built to work out-of-the-box with the Standard Edition, whereas significant work is needed to make them play nice with Silex.\n\nAlso, in my opinion, the default setup for Silex feels insufficient once a project's codebase grows beyond a certain size (because by default all controllers are in a single file, code files aren't sufficiently modularised / organised, etc). On the other hand, the Standard Edition feels like overkill for my projects, in terms of the modularisation / organisation that it encourages in its default setup. So, I guess I have yet to see a Symfony2 distribution that sits in a good middle ground in this respect."
    },
    {
      "date": "2013-10-21T10:58:39Z",
      "name": "Matt Robinson",
      "comment": "Mm, I get the point about bundles. In my experience, which could just be luck, most of the bundles I've needed have actually wrapped 3rd party framework-independent libraries, so I've been able to just use those directly (usually by writing a slim service-provider). Packagist.org is a great resource for that.\n\nCouple of things you might want to look at in that case, are <a href=\"http://yolophp.com\">yolophp</a> (which is a sort of joke / teaching aid whose name still makes me wince; but is a reimplementation of Silex using <em>only</em> Symfony components, so potentially capable of loading some bundles), and @Fabpot's article on <a href=\"http://fabien.potencier.org/article/69/packing-a-symfony-full-stack-framework-application-in-one-file-introduction\">packing the Symfony2 framework into a single file</a>; you don't have to go that far, but it has some interesting info on what parts of SF2 you can strip out to leave a leaner framework that might suit your needs better.\n\nI agree that the default setup for Silex isn't great for growth, but then it's a micro-framework: you get the bare minimum out of the box and the rest is up to you. It can be daunting not having a structure defined for you, but it can also be liberating. I've done a LOT of refactoring on my Silex projects as the projects I've written become better defined and/or I've learned or thought of better ways to do things.\n\nBack to Silex. It's totally possible to make large applications with Silex; the <code>ServiceControllerServiceProvider</code> is one way to start. You can pick a structure that suits the scale of your project. I've got one big Silex project going now, and the structure I picked for it was to select discrete blocks of functionality and package them as Controller & Service providers (i.e. <code>register()</code> sets up the services, and the <code>boot()</code> method calls <code>$app->mount('/', $this->connect($app))</code> which loads the routes, so entire blocks of the site can be enabled, developed and maintained fairly separately). You could also use StackPHP's <code>UrlMapper</code> and <code>LazyLoadingHttpKernel</code> to split your app into multiple small apps and only load the one you need. <a href=\"https://github.com/igorw/ConfigServiceProvider\">ConfigServiceProvider</a> can load config files based on an environment variable, which is also very handy. Good luck!"
    },
    {
      "date": "2013-10-21T11:02:43Z",
      "name": "Matt Robinson",
      "comment": "Oh! And the <a href=\"http://rad.knplabs.com\">Symfony RAD Edition</a> might also be worth a look-in, although it still feeds on YAML files, so may not really be your thing."
    },
    {
      "date": "2014-06-28T06:33:17Z",
      "name": "Titouan Galopin",
      "url": "http://titouangalopin.com/",
      "comment": "Hello!\n\nInteresting post but I wanted to correct some big mistakes here:\n\n<blockquote>You have to specify the \"namespace path\" using the \"namespace\" declaration at the top of every single file in your project that contains namespaced classes ...</blockquote>\n\nLearn the difference between PHP namespaces and Python packages. PHP never told anyone that namespaces should be mapped to a directory structure, and that's where the PHP implementation is great: a namespace is just a box for a bunch of code. A single file could contain all classes of the namespace, PHP does not care. It's because of its use with <code>spl_autoloader_register</code> that the system is great, but you don't have to use it. So it's coherent to not do such automatic determination of the namespace.\n\n<blockquote>You can only import namespaces using their absolute path, resulting in overly verbose \"use\" declarations all over the place; wheras in other (saner) languages relative (and wildcard) namespace imports are possible</blockquote>\n\nJust false. Learn a bit about PHP:\n\n<pre class=\"php\"><code>use Doctrine\\Some\\AbsoluteNamespace\\Path;\n$class = new Path\\SomeClass();</code></pre>\n\n<blockquote>You're able to define configuration (e.g. routing callbacks) in multiple formats, with the preferred format being YAML (although raw PHP configuration is also possible) ...</blockquote>\n\nAnd in which framework don't you have to learn things before to use it? It's a matter of choices, YAML is just much better for raw configuration where XML is great for services definitions and PHP for dynamic configuration. It's because of the possible uses of Symfony that many formats exist.\n\n<blockquote>Only a class method can be a routing callback, a class itself or a stand-alone function cannot be a callback, as the routing system is too tightly coupled with PHP's class- and method-based namespace system</blockquote>\n\nFalse too. A routing callback can be any function. The case about the class is just stupid: how would you map a route to a complete class?!\n\n<blockquote>An overly complex and multi-levelled directory structure is needed for even the simplest projects ...</blockquote>\n\nTry to do a real big project once, and you will get why it's really great to have such a structure. Symfony is for large profesionnal projects, Try to use an adapted framework for your projects.\n\nI worked a lot with Django, CodeIgniter, Zend Framework. I took a glimpse to a lot of web framework in various languages. And until now, I found that the best one are clearly Symfony and Ruby on Rails. For big projects, they are just the bests.\n\nI don't like the \"mode\" to dislike PHP because it is \"badly thought\". That's just not true. PHP has in mind to be as intuitive to use as possible. That means that sometimes, as not everyone has the same intuition, you would find things unnatural. However, on the other hand, it's MUCH easier to create a web projet in PHP than it is in Ruby.\n\nI could talk a lot about it, and I know PHP is not the best language in the world (clearly :) ), but this article's arguments are the wrong ones."
    }
  ]
}
