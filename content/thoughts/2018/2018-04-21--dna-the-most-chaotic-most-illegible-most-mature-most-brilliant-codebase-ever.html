---
title: "DNA: the most chaotic, most illegible, most mature, most brilliant codebase ever"
date: 2018-04-21
permalink: /thoughts/2018/04/dna-the-most-chaotic-most-illegible-most-mature-most-brilliant-codebase-ever/
teaser: |-
  As a computer programmer &ndash; i.e. as someone whose day job is to write relatively dumb, straight-forward code, that controls relatively dumb, straight-forward machines &ndash; <a href="https://en.wikipedia.org/wiki/DNA">DNA</a> is a fascinating thing. <a href="https://ds9a.nl/amazing-dna/">Other coders agree</a>. It has been called <a href="https://medium.com/@bert.hubert/dna-the-code-of-life-12db4a17c66d">the code of life</a>, and rightly so: the DNA that makes up a given organism's <a href="https://en.wikipedia.org/wiki/Genome">genome</a>, is the set of instructions responsible for virtually everything about how that organism grows, survives, behaves, reproduces, and ultimately dies in this universe.

  Most intriguing and most tantalising of all, is the fact that we humans still have virtually no idea how to interpret DNA in any meaningful way. It's <a href="http://www.bbc.co.uk/history/historic_figures/watson_and_crick.shtml">only since 1953</a> that we've understood what DNA even is; and it's <a href="https://www.genome.gov/12011238/an-overview-of-the-human-genome-project/">only since 2001</a> that we've been able to extract and to <a href="http://emboss.open-bio.org/html/use/ch05s02.html">gaze upon</a> instances of the complete human genome.

  [thumbnail watson-crick-dna.jpg Watson and Crick showing off their DNA model in 1953.<br><em>Image source:</em> <a href="https://www.slideshare.net/abhigiri02/a-complete-ppt-on-dna">A complete PPT on DNA (Slideshare)</a>.]

  As others have pointed out, the reason why we haven't had much luck in reading DNA, is because (in computer science parlance) it's not high-level source code, it's machine code (or, to be more precise, it's bytecode). So, DNA, which is <a href="http://www.dnaftb.org/22/">sequences of base-4 digits</a>, grouped into (most commonly) 3-digit "words" (known as "codons"), is no more easily decipherable than binary, which is <a href="http://www.mathcs.emory.edu/~cheung/Courses/170/Syllabus/01/binary.html">sequences of base-2 digits</a>, grouped into (for example) 8-digit "words" (known as "bytes"). And as anyone who has ever read or written binary (in binary, octal, or hex form, however you want to skin that cat) can attest, it's hard!

  In this musing, I'm going to compare genetic code and computer code. I am in no way qualified to write about this topic (particularly about the biology side), but it's fun, and I'm reckless, and this is my blog so for better or for worse nobody can stop me.
tags:
  - thoughtstopics/biology
  - thoughtstopics/genetics
  - thoughtstopics/philosophy
  - thoughtstopics/programming
---
As a computer programmer &ndash; i.e. as someone whose day job is to write relatively dumb, straight-forward code, that controls relatively dumb, straight-forward machines &ndash; <a href="https://en.wikipedia.org/wiki/DNA">DNA</a> is a fascinating thing. <a href="https://ds9a.nl/amazing-dna/">Other coders agree</a>. It has been called <a href="https://medium.com/@bert.hubert/dna-the-code-of-life-12db4a17c66d">the code of life</a>, and rightly so: the DNA that makes up a given organism's <a href="https://en.wikipedia.org/wiki/Genome">genome</a>, is the set of instructions responsible for virtually everything about how that organism grows, survives, behaves, reproduces, and ultimately dies in this universe.

Most intriguing and most tantalising of all, is the fact that we humans still have virtually no idea how to interpret DNA in any meaningful way. It's <a href="http://www.bbc.co.uk/history/historic_figures/watson_and_crick.shtml">only since 1953</a> that we've understood what DNA even is; and it's <a href="https://www.genome.gov/12011238/an-overview-of-the-human-genome-project/">only since 2001</a> that we've been able to extract and to <a href="http://emboss.open-bio.org/html/use/ch05s02.html">gaze upon</a> instances of the complete human genome.

[thumbnail watson-crick-dna.jpg Watson and Crick showing off their DNA model in 1953.<br><em>Image source:</em> <a href="https://www.slideshare.net/abhigiri02/a-complete-ppt-on-dna">A complete PPT on DNA (Slideshare)</a>.]

As others have pointed out, the reason why we haven't had much luck in reading DNA, is because (in computer science parlance) it's not high-level source code, it's machine code (or, to be more precise, it's bytecode). So, DNA, which is <a href="http://www.dnaftb.org/22/">sequences of base-4 digits</a>, grouped into (most commonly) 3-digit "words" (known as "codons"), is no more easily decipherable than binary, which is <a href="http://www.mathcs.emory.edu/~cheung/Courses/170/Syllabus/01/binary.html">sequences of base-2 digits</a>, grouped into (for example) 8-digit "words" (known as "bytes"). And as anyone who has ever read or written binary (in binary, octal, or hex form, however you want to skin that cat) can attest, it's hard!

In this musing, I'm going to compare genetic code and computer code. I am in no way qualified to write about this topic (particularly about the biology side), but it's fun, and I'm reckless, and this is my blog so for better or for worse nobody can stop me.

<h2>Authorship and motive</h2>

The first key difference that I'd like to point out between the two, is regarding who wrote each one, and why. For computer code, this is quite straightforward: a given computer program was written by one of your contemporary human peers (hopefully one who is still alive, as you can then ask him or her about anything that's hard to grok in the code), for some specific and obvious purpose &ndash; for example, to <a href="http://isweb.redwoods.edu/instruct/calderwoodd/diglogic/full.htm">add two numbers</a> together, or to move a <a href="http://time.com/3892662/pac-mans-35-years/">chomping yellow pac-man</a> around inside a maze, or to <a href="http://catifier.com/">add somersaulting cats</a> to an image.

For DNA, we don't know who, if anyone, wrote the first ever snippet of code &ndash; maybe it was <a href="https://www.ted.com/topics/god">G-d</a>, maybe it was <a href="https://www.brainpop.com/science/space/aliens/">aliens</a> from the <a href="http://memory-alpha.wikia.com/wiki/Delta_Quadrant">Delta Quadrant</a>, or maybe it was the random result of various chemicals <a href="https://briankoberlein.com/2015/05/05/shake-rattle-and-roll/">bashing into each other</a> within the primordial soup. And as for who wrote (and who continues to this day to write) all DNA after that, that too may well be The Almighty or The Borg, but the current theory of choice is that a given snippet of DNA basically <a href="http://nectunt.bifi.es/to-learn-more-overview/mechanisms-of-evolutionary-change/">keeps on re-writing itself</a>, and that this auto-re-writing happens (as far as we can tell) in a pseudo-random fashion.

[thumbnail the-scribe.jpg This guy didn't write binary or DNA, I'm pretty sure.<br><em>Image source:</em> <a href="https://artuk.org/discover/artworks/the-scribe-68808">Art UK</a>.]

Nor do we know why DNA came about in the first place. From a philosophical / logical point of view, not having an answer to the "who" question, kind of makes it impossible to address the "why", by defintion. If it came into existence randomly, then it would logically follow that it wasn't created for any specific purpose, either. And as for why DNA re-writes itself in the way that it does: it would seem that DNA's, <a href="https://seminalthought.blogspot.com.au/2012/10/immortality-and-will-to-live.html">and therefore life's, main purpose</a>, as far as the DNA itself is concerned, is <a href="http://www.icr.org/article/darwinism-survival-without-purpose/">simply to continue existing / surviving</a>, as evidenced by the fact that DNA's self-modification results, on average, over the long-term, in it becoming <a href="http://theconversation.com/how-australias-animals-and-plants-are-changing-to-keep-up-with-the-climate-74247">ever more optimally adapted</a> to its surrounding environment.

<h2>Management processes</h2>

For building and maintaining computer software, regardless of "methodology" (e.g. <a href="https://airbrake.io/blog/sdlc/waterfall-model">waterfall</a>, <a href="https://www.scrumalliance.org/learn-about-scrum">scrum</a>, <a href="http://www.extremeprogramming.org/">extreme programming</a>), the vast majority of the time there are a number of common non-dev processes in place. Apart from every geek's favourite bit, a.k.a. "coding", there is (to name a few): requirements gathering; spec writing; code review; testing / <a href="https://www.test-institute.org/What_is_Software_Quality_Assurance.php">QA</a>; version control; release management; <a href="http://guides.beanstalkapp.com/deployments/best-practices.html">staged deployment</a>; and documentation. The whole point of these processes, is to ensure: that a given snippet of code achieves a clear business or technical outcome; that it works as intended (both in isolation, and when integrated into the larger system); that the change it introduces is clearly tracked and is well-communicated; and that the codebase stays maintainable.

For DNA, there is little or no parallel to most of the above processes. As far as we know, when DNA code is modified, there are no requirements defined, there is no spec, there is no review of the change, there is no staging environment, and there is no documentation. DNA seems to follow my former boss's preferred methodology: <a href="https://www.urbandictionary.com/define.php?term=JFDI">JFDI</a>. New code is written, nobody knows what it's for, nobody knows how to use it. Oh well. Straight into production it goes.

However, there is one process that DNA demonstrates in abundance: QA. Through a <a href="https://www.nature.com/scitable/topicpage/dna-damage-repair-mechanisms-for-maintaining-dna-344">variety of mechanisms</a>, the most important of which is <a href="http://www.dnaftb.org/28/">repair enzymes</a>, a given piece of DNA code is constantly checked for integrity errors, and these errors are generally repaired. Mutations (i.e. code changes) can occur during replication due to imperfect copying, or at any other time due to environmental factors. Depending on the genome (i.e. the species) in question, and depending on the gene in question, the level of enforcement of DNA integrity can vary, from "very relaxed" to "very strict". For example, bacteria <a href="http://sandwalk.blogspot.com.au/2007/07/mutation-rates.html">experience far more mutation between generations</a> than humans do. This is because some genomes consider themselves to still be in "beta", and are quite open to potentially dangerous experimentation, while other genomes consider themselves "mature", and so <a href="http://www.molecularecologist.com/2013/10/getting-started-with-ultra-conserved-elements/">prefer less change</a> and greater stability. Thus a <a href="https://www.nature.com/scitable/topicpage/genetic-mutation-1127">balance is achieved</a> between preservation of genes, and evolution.

<h2>The coding process</h2>

For computer software, the actual process of coding is relatively structured and rational. The programmer refers to the spec &ndash; which could be anything from a one-sentence verbal instruction bandied over the water-cooler, to a <a href="http://www.bridging-the-gap.com/i-am-letting-go-of-the-big-thick-requirements-document-are-you/">50-page PDF</a> (preferably it's something in between those two extremes) &ndash; before putting hands to keyboard, and also regularly while coding.

The programmer visualises the rough overall code change involved (or the rough overall components of a new codebase), and starts writing. He or she will generally switch between <a href="https://www.johndcook.com/blog/2012/12/06/top-down-bottom-up/">top-down</a> (focusing on the framework and on "glue code") and bottom-up (focusing on individual functions) several times. The code will generally be refined, in response to feedback during code review, to fixing defects in the change, and to the programmer's constant critiquing of his or her own work. Finally, the code will be "done" &ndash; although inevitably it will <a href="https://www.software.ac.uk/developing-maintainable-software">need to be modified</a> in future, in response to new requirements, at which point it's time to rinse and repeat all of the above.

For DNA, on the other hand, the process of coding appears (unless we're missing something?) to be akin to <a href="https://evolution.berkeley.edu/evolibrary/article/mutations_07">letting a dog randomly roll around</a> on the keyboard while the editor window is open, then cleaning up the worst of the damage, then seeing if anything interesting was produced. Not the most scientific of methods, you might say? But hey, that's science! And it would seem that, amazingly, if you do that on a massively distributed enough scale, over a long enough period of time, you get intelligent life.

[thumbnail dog-writing-dna.jpg DNA modification in progress.<br><em>Image source:</em> <a href="https://www.surveymonkey.co.uk/r/63LDFR7">DogsToday</a>.]

When you think about it, that approach isn't really dissimilar to the current state-of-the-art in machine learning. Getting anything approaching significant or accurate results with machine learning models, has only been possible quite recently, thanks to the availability of <a href="http://infolab.stanford.edu/~ullman/mmds/book.pdf">massive data sets</a>, and of <a href="https://www.alcf.anl.gov/intrepid">massive hardware platforms</a> &ndash; and even when you let a ML algorithm loose in that environment for a decent period of time, it produces results that contain a lot of noise. So maybe we are indeed onto something with our current approach to ML, although I don't think we're quite onto the generation of truly intelligent software just yet.

<h2>Grokking it</h2>

Most computer code that has been written by humans for the past 40 years or so, has been high-level source code (i.e. "<a href="https://softwareengineering.stackexchange.com/questions/303117/is-c-programming-language-low-level-or-high-level">C and up</a>"). It's written primarily to express business logic, rather than to tell the <a href="http://www.ict.griffith.edu.au/~johnt/1004ICT/lectures/lecture07/Cragon-pp1-13.html">Von Neumann machine</a> (a.k.a. the computer hardware) exactly what to do. It's up to the compiler / interpreter, to translate that "call function <code>abc</code>" / "divide variable <code>pqr</code> by 50" / "write the string <code>I feel like a Tooheys</code> to file <code>xyz</code>" code, into "load value of register <code>123</code>" / "put that value in register <code>456</code>" / "send value to bus <code>789</code>" code, which in turn actually gets represented in memory as 0s and 1s.

This is great for us humans, because &ndash; assuming we can get our hands on the high-level source code &ndash; we can quite easily grok the purpose of a given piece of code, without having to examine the gory details of what the computer physically does, step-by-tiny-tedious-step, in order to achieve that noble purpose.

DNA, as I said earlier, is not high-level source code, it's machine code / bytecode (more likely the latter, in which case the actual machine code of living organisms is the proteins, and other things, that DNA / RNA gets "compiled" to). And it now seems pretty clear that there is no higher source code &ndash; DNA, which consists of long sequences of Gs, As, Cs, and Ts, is the actual source. The code did not start in a form where a given gene is expressed logically / procedurally &ndash; a form from which it could be translated down to <a href="https://tandem.bu.edu/knex/base.pairs.knex.html">base pairs</a>. The start and the end state of the code <em>is</em> as base pairs.

[thumbnail hieroglyphic.jpg A code that was cracked - can the same be done for DNA?<br><em>Image source:</em> <a href="https://www.tun.com/blog/yale-university-hieroglyphic-carvings/">The University Network</a>.]

It also seems that DNA is harder to understand than machine / assembly code for a computer, because an organic cell is a much more complex piece of hardware than a Von Neumann-based computer (which itself is a specific type of <a href="https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html">Turing machine</a>). That's why humans were perfectly capable of programming computers using only machine / assembly code to begin with, and why some specialised programmers continue primarily coding at that level to this day. For a computer, the machine itself only consists of a few simple components, and the instruction set is relatively small and unambiguous. For an organic cell, the physical machinery is far more complex (and whether a <a href="https://www.quora.com/Is-DNA-a-Turing-machine">DNA-containing cell is a Turing machine</a> is itself currently an open research question), and the instruction set is riddled with ambiguous, context-specific meanings.

Since all we have is the DNA bytecode, all current efforts to "decode DNA" focus on comparing long strings of raw base pairs with each other, across different genes / chromosomes / genomes. This is akin to trying to understand what software does by lining up long strings of compiled hex digits for different binaries side-by-side, and spotting sequences that are kind-of similar. So, no offense intended, but the current state-of-the-art in "DNA decoding" strikes me as incredibly primitive, cumbersome, and futile. It's a miracle that we've made any progress at all with this approach, and it's only thanks to some highly intelligent people employing their best mathematical pattern analysis techniques, that we have indeed gotten anywhere.

<h2>Where to from here?</h2>

Personally, I feel that we're only really going to "crack" the DNA puzzle, if we're able to reverse-engineer raw DNA sequences into some sort of higher-level code. And, considering that reverse-engineering raw binary into a higher-level programming language (such as C) is a very difficult endeavour, and that doing the same for DNA is bound to be even harder, I think we have our work cut out for us.

My interest in the DNA puzzle was first piqued, when I heard a talk at PyCon AU 2016: <a href="https://2016.pycon-au.org/schedule/151/view_talk?day=friday">Big data biology for pythonistas: getting in on the genomics revolution</a>, presented by <a href="http://daryavanichkina.com/">Darya Vanichkina</a>. In this presentation, DNA was presented as a riddle that more programmers can and should try to help solve. Since then, I've thought about the riddle now and then, and I have occasionally read some of the plethora of available online material about DNA and genome sequencing.

DNA is an amazing thing: for <a href="https://www.wired.com/2010/12/dna-life-fossils/">approximately 4 billion years</a>, it has been spreading itself across our planet, modifying itself in bizarre and colourful ways, and ultimately evolving (according to the laws of <a href="https://www.livescience.com/445-darwin-natural-selection-work-humans.html">natural selection</a>) to become the codebase that defines the behaviour of primitive lifeforms such as humans (and even intelligent lifeforms <a href="https://www.nationalgeographic.com/magazine/2015/05/dolphin-intelligence-human-communication/">such as dolphins</a>!).

[thumbnail dolphins.jpg Dolphins! (Brainier than you are).<br><em>Image source:</em> <a href="https://www.daysoftheyear.com/days/dolphin-day/">Days of the Year</a>.]

So, let's be realistic here: it took DNA that long to reach its current form; we'll be doing well if we can start to understand it properly within the next 1,000 years, if we can manage it at all before the humble blip on Earth's timeline that is human civilisation fades altogether.
